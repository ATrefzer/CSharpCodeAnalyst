using System.Diagnostics;
using CodeParser.Parser.Config;
using Contracts.Common;
using Contracts.Graph;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace CodeParser.Parser;

/// <summary>
///     Parses a solution and builds a code graph.
///     There are two phases:
///     1. Find all code elements and their parent-child relationships.
///     2. Build the dependencies between the code elements.
/// </summary>
public class Parser(ParserConfig config)
{
    public Progress Progress { get; set; } = new();

    private readonly ParserDiagnostics _diagnostics = new ParserDiagnostics();

    public IParserDiagnostics Diagnostics => _diagnostics;

    public async Task<CodeGraph> ParseSolution(string solutionPath)
    {
        _diagnostics.Clear();

        var sw = Stopwatch.StartNew();

        Progress.SendProgress("Compiling ...");

        var workspace = MSBuildWorkspace.Create();
        workspace.WorkspaceFailed += Workspace_WorkspaceFailed;
        var solution = await workspace.OpenSolutionAsync(solutionPath);


        sw.Stop();
        Trace.WriteLine("Compiling: " + sw.Elapsed);
        sw = Stopwatch.StartNew();

        // First Pass: Build Hierarchy
        var phase1 = new HierarchyAnalyzer(Progress, config);
        var (codeGraph, artifacts) = await phase1.BuildHierarchy(solution);

        sw.Stop();
        Trace.WriteLine("Finding code elements: " + sw.Elapsed);
        sw = Stopwatch.StartNew();

        // Second Pass: Build Relationships
        // We don't need to iterate over the projects
        var phase2 = new RelationshipAnalyzer(Progress);
        await phase2.AnalyzeRelationshipsMultiThreaded(solution, codeGraph, artifacts);

        sw.Stop();
        Trace.WriteLine("Analyzing relationships: " + sw.Elapsed);

        // Makes the cycle detection easier because I never get to the assembly as shared ancestor
        // for a nested relationships.
        InsertGlobalNamespaceIfUsed(codeGraph);

        // Debug.Assert(_codeGraph.Nodes.Values.All(c => IsDistinct(c.SourceLocations)));
        // await File.WriteAllTextAsync("d:\\debug.txt", _codeGraph.ToDebug());

        return codeGraph;
    }

    private void Workspace_WorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
    {
        _diagnostics.Add(e.Diagnostic);
        Trace.WriteLine(e.Diagnostic.Message);
    }

    private bool IsDistinct<T>(List<T> collection)
    {
        return collection.Count == collection.Distinct().Count();
    }

    /// <summary>
    ///     If any assembly uses the global namespace we add the global namespace to all assemblies.
    ///     For example a unit test assembly may have the autogenerated Main.
    /// </summary>
    private void InsertGlobalNamespaceIfUsed(CodeGraph codeGraph)
    {
        var global = "global";
        var assemblies = codeGraph.Nodes.Values.Where(n => n.Parent is null).ToList();
        Debug.Assert(assemblies.All(a => a.ElementType == CodeElementType.Assembly));
        var isGlobalNsUsed = assemblies.Any(a => a.Children.Any(c => c.ElementType != CodeElementType.Namespace));

        var newGlobalNamespaces = new List<CodeElement>();
        if (isGlobalNsUsed)
        {
            foreach (var assembly in assemblies)
            {
                var children = assembly.Children.ToList();

                var id = Guid.NewGuid().ToString();
                var fullName = assembly.FullName + "." + global;
                var globalNs = new CodeElement(id, CodeElementType.Namespace, global, fullName, assembly);
                newGlobalNamespaces.Add(globalNs);

                assembly.Children.Add(globalNs);

                // Move elements
                foreach (var child in children)
                {
                    child.MoveTo(globalNs);
                }
            }

            // Don't modify collection during iteration
            foreach (var globalNs in newGlobalNamespaces)
            {
                codeGraph.Nodes[globalNs.Id] = globalNs;
            }
        }
    }
}