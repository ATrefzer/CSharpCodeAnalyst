using System.Diagnostics;
using CodeParser.Parser.Config;
using Contracts.Graph;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace CodeParser.Parser;

public class ParserProgressArg(string message) : EventArgs
{
    public string Message { get; set; } = message;
}


/// <summary>
/// TODO describe why the multi threading is safe.
/// </summary>
public partial class Parser(ParserConfig config)
{
    private object _lock = new object();
    private readonly CodeGraph _codeGraph = new();

    private readonly ParserConfig _config = config;
    private readonly Dictionary<string, ISymbol> _elementIdToSymbolMap = new();
    private readonly HashSet<string> _projectFilePaths = [];
    private readonly Dictionary<string, CodeElement> _symbolKeyToElementMap = new();

    public event EventHandler<ParserProgressArg>? ParserProgress;

    public async Task<CodeGraph> ParseSolution(string solutionPath)
    {
        Clear();

        ParserProgress?.Invoke(this, new ParserProgressArg("Compiling ..."));

        var workspace = MSBuildWorkspace.Create();
        var solution = await workspace.OpenSolutionAsync(solutionPath);

        CollectAllFilePathInSolution(solution);

        // First Pass: Build Hierarchy
        await BuildHierarchy(solution);

        // Second Pass: Build Relationships
        // We don't need to iterate over the projects
        await AnalyzeRelationshipsMultiThreaded(solution);

        Clear();

        // Makes the cycle detection easier because I never get to the assembly as shared ancestor
        // for a nested relationships.
        InsertGlobalNamespaceIfUsed();

        // Debug.Assert(_codeGraph.Nodes.Values.All(c => IsDistinct(c.SourceLocations)));

        // await File.WriteAllTextAsync("d:\\debug.txt", _codeGraph.ToDebug());

        return _codeGraph;
    }

    private bool IsDistinct<T>(List<T> collection)
    {
        return collection.Count == collection.Distinct().Count();
    }

    private void Clear()
    {
        _symbolKeyToElementMap.Clear();
        _elementIdToSymbolMap.Clear();
        _projectFilePaths.Clear();
    }

    /// <summary>
    ///     If any assembly uses the global namespace we add the global namespace to all assemblies.
    ///     For example a unit test assembly may have the autogenerated Main.
    /// </summary>
    private void InsertGlobalNamespaceIfUsed()
    {
        var global = "global";
        var assemblies = _codeGraph.Nodes.Values.Where(n => n.Parent is null).ToList();
        Debug.Assert(assemblies.All(a => a.ElementType == CodeElementType.Assembly));
        var isGlobalNsUsed = assemblies.Any(a => a.Children.Any(c => c.ElementType != CodeElementType.Namespace));

        var newGlobalNamespaces = new List<CodeElement>();
        if (isGlobalNsUsed)
        {
            foreach (var assembly in assemblies)
            {
                var children = assembly.Children.ToList();

                var id = Guid.NewGuid().ToString();
                var fullName = assembly.FullName + "." + global;
                var globalNs = new CodeElement(id, CodeElementType.Namespace, global, fullName, assembly);
                newGlobalNamespaces.Add(globalNs);

                assembly.Children.Add(globalNs);

                // Move elements
                foreach (var child in children)
                {
                    child.MoveTo(globalNs);
                }
            }

            // Don't modify collection during iteration
            foreach (var globalNs in newGlobalNamespaces)
            {
                _codeGraph.Nodes[globalNs.Id] = globalNs;
            }
        }
    }

    private void CollectAllFilePathInSolution(Solution solution)
    {
        foreach (var project in solution.Projects)
        {
            if (_config.IsProjectIncluded(project.Name) is false)
            {
                continue;
            }

            foreach (var document in project.Documents)
            {
                if (document.FilePath != null)
                {
                    _projectFilePaths.Add(document.FilePath);
                }
            }
        }
    }

    /// <summary>
    ///     Since I iterate over the compilation units (to get rid of external code)
    ///     any seen namespace, even "namespace X.Y.Z;", ends up as
    ///     namespace Z directly under the assembly node.
    ///     So If I see namespace X.Y.Z I create X, Y, Z and set them as parent child.
    /// </summary>
    private CodeElement GetOrCreateCodeElementWithNamespaceHierarchy(ISymbol symbol,
        CodeElementType elementType, CodeElement initialParent, SourceLocation? location)
    {
        if (symbol is INamespaceSymbol namespaceSymbol)
        {
            var namespaces = new Stack<INamespaceSymbol>();
            var current = namespaceSymbol;

            // Build the stack of nested namespaces
            while (current is { IsGlobalNamespace: false })
            {
                namespaces.Push(current);
                current = current.ContainingNamespace;
            }

            var parent = initialParent;

            // Create or get each namespace in the hierarchy
            while (namespaces.Count > 0)
            {
                // We create the whole chain when encountering namespace X.Y.Z;
                // So I give all the same source location. Right?
                var ns = namespaces.Pop();

                // The location is only valid for the input namespace symbol.
                var nsLocation = ReferenceEquals(ns, namespaceSymbol) ? location : null;
                var nsElement = GetOrCreateCodeElement(ns, CodeElementType.Namespace, parent, nsLocation);
                parent = nsElement;
            }

            return parent;
        }

        // For non-namespace symbols, use the original logic
        return GetOrCreateCodeElement(symbol, elementType, initialParent, location);
    }

    /// <summary>
    ///     Note: We store the symbol used to build the hierarchy.
    ///     If used in different a compilation unit the symbol may be another instance..
    /// </summary>
    private CodeElement GetOrCreateCodeElement(ISymbol symbol, CodeElementType elementType, CodeElement? parent,
        SourceLocation? location)
    {
        var symbolKey = symbol.Key();

        // We may encounter namespace declarations in many files.
        if (_symbolKeyToElementMap.TryGetValue(symbolKey, out var existingElement))
        {
            UpdateCodeElementLocations(existingElement, location);
            WarnIfCodeElementHasMultipleSymbols(symbol, existingElement);
            return existingElement;
        }

        var name = symbol.Name;
        var fullName = symbol.BuildSymbolName();
        var newId = Guid.NewGuid().ToString();

        var element = new CodeElement(newId, elementType, name, fullName, parent);

        UpdateCodeElementLocations(element, location);

        parent?.Children.Add(element);
        _codeGraph.Nodes[element.Id] = element;
        _symbolKeyToElementMap[symbolKey] = element;

        // We need the symbol in phase2 when analyzing the relationships.
        if (symbol is not INamespaceSymbol)
        {
            _elementIdToSymbolMap[element.Id] = symbol;
        }

        SendParserPhase1Progress(_codeGraph.Nodes.Count);

        return element;
    }

    private void WarnIfCodeElementHasMultipleSymbols(ISymbol symbol, CodeElement existingElement)
    {
        if (symbol is not INamespaceSymbol)
        {
            // Get warning if we have different symbols for the same element.
            if (_elementIdToSymbolMap[existingElement.Id].Equals(symbol, SymbolEqualityComparer.Default) is false)
            {
                // Happens if two projects in the solution have the same name.
                // You lose one of them.
                Trace.WriteLine("(!) Found element with multiple symbols: " + symbol.ToDisplayString());
            }
        }
    }

    private static void UpdateCodeElementLocations(CodeElement element, SourceLocation? location)
    {
        if (element.ElementType == CodeElementType.Namespace)
        {
            // Namespaces are spread over many files,
            // and it is useless for the user to see all of them.
            return;
        }

        if (location != null)
        {
            element.SourceLocations.Add(location);
        }
    }


    private void SendParserPhase1Progress(int numberOfCodeElements)
    {
        if (numberOfCodeElements % 10 == 0)
        {
            var msg = $"Phase 1/2: Already found {numberOfCodeElements} code elements.";
            var args = new ParserProgressArg(msg);

            ParserProgress?.Invoke(this, args);
        }
    }

    /// <summary>
    ///     Get the source location of a syntax node
    /// </summary>
    private static SourceLocation GetLocation(SyntaxNode node)
    {
        var location = new SourceLocation(
            node.SyntaxTree.FilePath,
            node.GetLocation().GetLineSpan().StartLinePosition.Line + 1,
            node.GetLocation().GetLineSpan().StartLinePosition.Character + 1);
        return location;
    }

    /// <summary>
    ///     Gets the source locations of a semantic symbol. We may have more than one location if
    ///     the symbol is defined over several files (i.e. partial classes)
    /// </summary>
    private static List<SourceLocation> GetLocations(ISymbol symbol)
    {
        return symbol.Locations.Select(l => new SourceLocation
        {
            File = l.SourceTree?.FilePath ?? "",
            Line = l.GetLineSpan().StartLinePosition.Line + 1,
            Column = l.GetLineSpan().StartLinePosition.Character + 1
        }).ToList();
    }


    private void AddRelationship(CodeElement source, RelationshipType type,
        CodeElement target,
        List<SourceLocation> sourceLocations)
    {
        lock (_lock)
        {
            var existingRelationship = source.Relationships.FirstOrDefault(d =>
                d.TargetId == target.Id && d.Type == type);

            if (existingRelationship != null)
            {
                // Note we may read some relationships more than once through different ways but that's fine.
                // For example identifier and member access of field.
                var newLocations = sourceLocations.Except(existingRelationship.SourceLocations);
                existingRelationship.SourceLocations.AddRange(newLocations);
            }
            else
            {
                var newRelationship = new Relationship(source.Id, target.Id, type);
                newRelationship.SourceLocations.AddRange(sourceLocations);
                source.Relationships.Add(newRelationship);
            }
        }
    }
}