using System.Diagnostics;
using CodeParser.Parser.Config;
using Contracts.Common;
using Contracts.Graph;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace CodeParser.Parser;

/// <summary>
///     Parses a solution and builds a code graph.
///     There are two phases:
///     1. Find all code elements and their parent-child relationships.
///     2. Build the dependencies between the code elements.
/// </summary>
public class Parser(ParserConfig config)
{

    private readonly ParserDiagnostics _diagnostics = new();
    private readonly Progress _progress = new Progress();


    public IProgress Progress
    {
        get => _progress;
    }

    public IParserDiagnostics Diagnostics
    {
        get => _diagnostics;
    }
    
    
    public async Task<CodeGraph> Parse(string path)
    {
        var extension = Path.GetExtension(path).ToLowerInvariant();
    
        return extension switch
        {
            ".sln" => await ParseSolution(path),
            ".csproj" => await ParseProject(path),
            _ => throw new ArgumentException($"Unsupported file type: {extension}. Expected .sln or .csproj")
        };
    }
    
    /// <summary>
    /// Parses a single project and builds a code graph.
    /// </summary>
    private async Task<CodeGraph> ParseProject(string projectPath)
    {
        _diagnostics.Clear();
        var sw = Stopwatch.StartNew();

        _progress.SendProgress("Compiling project ...");

        using var workspace = MSBuildWorkspace.Create();
        workspace.WorkspaceFailed += Workspace_WorkspaceFailed;
        var project = await workspace.OpenProjectAsync(projectPath);
        
        // Create a solution from the single project
        var solution = project.Solution;

        sw.Stop();
        Trace.TraceInformation("Compiling: " + sw.Elapsed);

        return await ParseSolutionInternal(solution);
    }

    /// <summary>
    /// Parses a complete solution and builds a code graph.
    /// </summary>
    private async Task<CodeGraph> ParseSolution(string solutionPath)
    {
        _diagnostics.Clear();
        var sw = Stopwatch.StartNew();

        _progress.SendProgress("Compiling solution ...");

        using var workspace = MSBuildWorkspace.Create();
        workspace.WorkspaceFailed += Workspace_WorkspaceFailed;
        var solution = await workspace.OpenSolutionAsync(solutionPath);

        sw.Stop();
        Trace.TraceInformation("Compiling: " + sw.Elapsed);

        return await ParseSolutionInternal(solution);
    }

    /// <summary>
    /// Internal method that does the actual parsing work.
    /// </summary>
    private async Task<CodeGraph> ParseSolutionInternal(Solution solution)
    {
        var sw = Stopwatch.StartNew();

        // First Pass: Build Hierarchy
        var phase1 = new HierarchyAnalyzer(_progress, config);
        var (codeGraph, artifacts) = await phase1.BuildHierarchy(solution);

        sw.Stop();
        Trace.TraceInformation("Finding code elements: " + sw.Elapsed);
        sw = Stopwatch.StartNew();

        // Second Pass: Build Relationships
        var phase2 = new RelationshipAnalyzer(_progress, config);
        await phase2.AnalyzeRelationshipsMultiThreaded(solution, codeGraph, artifacts);

        sw.Stop();
        Trace.TraceInformation("Analyzing relationships: " + sw.Elapsed);

        // Makes the cycle detection easier because I never get to the assembly as shared ancestor
        // for a nested relationships.
        InsertGlobalNamespaceIfUsed(codeGraph);

#if DEBUG
        CodeGraphPlausibilityChecks.PlausibilityChecks(codeGraph);
#endif
        //await File.WriteAllTextAsync("d:\\debug0.txt", codeGraph.ToDebug());

        return codeGraph;
    }

    
    private void Workspace_WorkspaceFailed(object? sender, WorkspaceDiagnosticEventArgs e)
    {
        _diagnostics.Add(e.Diagnostic);
        Trace.WriteLine(e.Diagnostic.Message);
    }

    /// <summary>
    ///     If any assembly uses the global namespace we add the global namespace to all assemblies.
    ///     For example a unit test assembly may have the autogenerated Main.
    /// </summary>
    private static void InsertGlobalNamespaceIfUsed(CodeGraph codeGraph)
    {
        const string global = "global";
        var assemblies = codeGraph.GetRoots();
        Debug.Assert(assemblies.All(a => a.ElementType == CodeElementType.Assembly));
        var isGlobalNsUsed = assemblies.Any(a => a.Children.Any(c => c.ElementType != CodeElementType.Namespace));

        var newGlobalNamespaces = new List<CodeElement>();
        if (isGlobalNsUsed)
        {
            foreach (var assembly in assemblies)
            {
                var childrenCopy = assembly.Children.ToList();

                var id = Guid.NewGuid().ToString();
                var fullName = assembly.FullName + "." + global;
                var globalNs = new CodeElement(id, CodeElementType.Namespace, global, fullName, assembly);
                newGlobalNamespaces.Add(globalNs);

                assembly.Children.Add(globalNs);

                // Move elements
                foreach (var child in childrenCopy)
                {
                    child.MoveTo(globalNs);
                }
            }

            // Don't modify collection during iteration
            foreach (var globalNs in newGlobalNamespaces)
            {
                codeGraph.Nodes[globalNs.Id] = globalNs;
            }
        }
    }
}